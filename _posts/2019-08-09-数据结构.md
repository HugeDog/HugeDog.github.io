---
categories: Algo
tags: 数据结构 算法导论
# music-id: 20090402
---
## 基本数据结构
在本章中，我们要讨论如何通过使用指针的简单数据结构来表示动态集合。虽然运用指针可以构造多种复杂的数据结构，但这里只介绍几种基本的结构：栈、队列、链表和有根树。此外，我们还要介绍由数组构造对象和指针的方法。

### 栈和队列
**栈**中，被删除的是最近插入的元素，栈实现的是一种 **后进先出（LIFO）**策略。类似地，在队列中，被删去的总是在集合中存在的时间最长的那个元素：队列实现的是一种 **先进先出（FIFO）**策略。在计算机上实现栈和队列有几种有效的方式。
#### 栈
栈包含的操作有：PUSH、POP、STACK-EMPTY（判断栈是否为空）。
#### 队列
队列包含的操作有：ENQUEUE、DEQUEUE、QUEUE-EMPTY。
队列有队头和队尾，当有一个元素入队时，它被放在队尾位置，出队的元素则总是排在队头的那个。

### 链表
链表（Linked List），其中的各对象按线性顺序排列。数组的线性顺序是由数组下标决定的，然而与数组不同的是，链表的顺序是由各个对象里的指针决定的。链表为动态集合提供了一种简单而灵活的表示方法，并且能支持上节中列出的所有操作（但未必非常有效）。

链表可以有多种形式。它可以是单链接的或双链接的，可以是已排序的或未排序的，可以是循环的或非循环的。如果一个链表是 **单链接的**，则省略每个元素中的prev指针。如果链表是已排序的，则链表的线性顺序与链表元素中关键字的线性顺序一致；据此，最小的元素就是表头元素，而最大的元素则是表尾元素。如果链表是未排序的，则各元素可以以任何顺序出现。在 **循环链表**中，表头的prev指针指向表尾元素，而表尾元素的next指针则指向表头元素。我们可以将循环链表想象成一个各元素组成的圆环。
#### 链表的搜索
LIST-SEARCH(L, k)采用简单的线性搜索的方法，用于查找链表L中第一个关键字为k的元素，并返回指向该元素的指针。如果链表中没有关键字为k的对象，则该过程返回NIL。搜索一个有n个对象的链表，最坏情况下的运行时间为$\Theta(n)$。
#### 链表的插入
LIST-INSERT将x“连接入”到链表的前端，在一个含n个元素的链表上执行LIST-INSERT的运行时间是$O(1)$。
#### 链表的删除
过程LIST-DELETE将一个元素x从链表L中移除。该过程要求给定一个指向x的指针，然后通过修改一些指针，将x“删除出”该链表，运行时间为$O(1)$。如果要删除具有给定关键字值的元素，则必须先调用LIST-SEARCH找到该元素，最坏情况下运行时间为$\Theta(n)$。
#### 哨兵
> 链表中的哨兵虽然很少被提及，但是在LeetCode优秀的算法解法中常常出现。
实现上述操作过程时，往往要考虑表头表尾处的边界条件。

**哨兵（sentinel）**是一个哑对象，其作用是简化边界条件的处理。例如，假设在链表L中设置一个对象L.nil，该对象代表NIL，但也具有和其他对象相同的各个属性。对于链表代码中出现的每一处对NIL的引用，都代之以对哨兵L.nil的引用。这样的调整将一个常规的双向链表转变为一个 **有哨兵的双向循环链表**，哨兵L.nil位于表头和表尾之间。属性L.nil.next指向表头，L.nil.prev指向表尾。类似地，表尾的next属性和表头的prev属性同时指向L.nil。因为L.nil.next指向表头，我们就可以去掉属性L.head，并把对它的引用代替为对L.nil.next的引用。

哨兵基本不能降低数据结构相关操作的渐近时间界，但可以降低常数因子。然而，在另一些情况下，哨兵的使用使循环语句的代码更紧凑，从而降低了运行时间中$n$或$n^2$等项的系数。我们应当慎用哨兵。假如有许多个很短的链表，它们的哨兵所占用的额外的存储空间会造成严重的存储浪费。
### 指针和对象的实现
我所接触到的常用语言不存在 **同时不支持指针和对象数据类型**这种现象，在《算法导论》这本书中，考虑了该情况，对象用数组实现，而指针用数组下标实现。同时，该书还考虑了 **对象的分配与释放**，不愧是经典的算法教材。有兴趣的同学可以参阅该书P134-136。
### 有根树
链表的表示方法可以推广到任意同构的数据结构上。
#### 二叉树
链表中每一个元素有一个前驱，一个后继，还有一个元素值，所有元素都是同构的。
对于二叉树，每一个元素有一个父节点，一个左节点，一个右节点，所有元素也是同构的。
#### 分支无限制的有根树
树的孩子节点数无限制时，我们不知道预先分配多少个槽来存储孩子（指针），即使孩子数k限制在一个大的常数范围内，但若多数节点只有少量的孩子，则会浪费大量存储空间。

所幸的是，有一个巧妙的方法可以用来表示孩子数任意的树，该方法的优势在于，对任意n个节点的有根树，只需要$O(n)$的存储空间。这种**左孩子右兄弟表示法**为：
1. 每个节点都包含一个父节点指针p，且T.root指向树T的根节点；
2. x.left-child指向节点x最左边的孩子节点；
3. x.right-sibling指向x右侧相邻的兄弟节点。
4. 如果节点x没有孩子节点，x.left-child=NIL；如果节点x是其父节点的最右孩子，则x.right-sibling=NIL。

#### 树的其他表示方法
完全二叉树：堆（一个单数组+最末节点的下标表示）

还有很多其他的表示方法，哪种方法最优取决于具体应用。

## 散 列 表
许多应用都需要一种动态集合结构，它至少要支持INSERT、SEARCH、DELETE字典操作。散列表（Hash Table）是实现字典操作的一种有效数据结构。尽管最坏情况下，散列表中查找一个元素的时间与链表中查找的时间相同，达到了$\Theta(n)$，然而在实际应用中，散列表查找的性能是极好的，在一些合理的假设下，查找一个元素的平均时间是$O(1)$。

**当实际存储的关键字数目比全部的可能关键字总数要小时**，采用**散列表**就成为直接数组寻址的一种有效替代，因为散列表使用一个长度与实际存储的关键字数目成比例的数组来存储。在散列表中，不是直接把关键字作为数组的下标，而是根据关键字计算出相应的下标。

### 直接寻址表

当关键字的全域$U$比较小时，直接寻址是一种简单而有效的技术。假设某应用要用到一个动态集合，其中每个元素都是取自于全域$U=\{0, 1, ... m-1\}$中的一个关键字，这里$m$不是一个很大的数。另外，假设没有两个元素具有相同的关键字。

为表示动态集合，我们用一个数组，或称为**直接寻址表**，记为$T[0..m-1]$。其中每个位置，或称为槽（slot），对应全域$U$中的一个关键字。槽$k$指向集合中一个关键字为$k$的元素。如果该集合中没有关键字为$k$的元素，则$T[k]=NIL$。
### 散列表
在直接寻址方式下，具有关键字$k$的元素被存放在槽$k$中。在散列方式下，该元素存放在槽$h(k)$中；即利用散列函数$h$，由关键字$k$计算出槽的位置。这里，函数$h$将关键字的全域$U$映射到散列表$T[0..m-1]$的槽位上：

$$h: U\rightarrow\{0, 1, ... m-1\}$$

这里散列表的大小$m$一般要比$|U|$小得多。散列函数缩小了数组下标的范围，即减小了数组的大小。这里存在一个问题：两个关键字可能映射到同一个槽中。我们称这种情形为**冲突**。幸运的是，我们能找到有效的方法来解决冲突。当然，理想的解决方法是避免所有的冲突。我们可以试图选择一个合适的散列函数$h$来做到这一点。一个想法就是使$h$尽可能的“随机”，从而避免冲突或者使冲突的次数最小化。但是，由于$|U|>m$，故至少有两个关键字其散列值相同，所以要想完全避免冲突是不可能的。因此，我们一方面可以通过精心设计的散列函数来尽量减少冲突的次数，另一方面仍需要有解决可能出现冲突的办法。

后面会介绍两种方法，一个是**链接法**，另一个是**开放寻址法**。
。
## 二叉搜索树
待续...
## 红黑树
待续...
## 数据结构的扩张
待续...
