---
categories: Algo
tags: 数据结构 算法导论
---
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>
## 基本数据结构
在本章中，我们要讨论如何通过使用指针的简单数据结构来表示动态集合。虽然运用指针可以构造多种复杂的数据结构，但这里只介绍几种基本的结构：栈、队列、链表和有根树。此外，我们还要介绍由数组构造对象和指针的方法。

### 栈和队列
**栈**中，被删除的是最近插入的元素，栈实现的是一种 **后进先出（LIFO）**策略。类似地，在队列中，被删去的总是在集合中存在的时间最长的那个元素：队列实现的是一种 **先进先出（FIFO）**策略。在计算机上实现栈和队列有几种有效的方式。
#### 栈
栈包含的操作有：PUSH、POP、STACK-EMPTY（判断栈是否为空）。
#### 队列
队列包含的操作有：ENQUEUE、DEQUEUE、QUEUE-EMPTY。
队列有队头和队尾，当有一个元素入队时，它被放在队尾位置，出队的元素则总是排在队头的那个。

### 链表
链表（Linked List），其中的各对象按线性顺序排列。数组的线性顺序是由数组下标决定的，然而与数组不同的是，链表的顺序是由各个对象里的指针决定的。链表为动态集合提供了一种简单而灵活的表示方法，并且能支持上节中列出的所有操作（但未必非常有效）。

链表可以有多种形式。它可以是单链接的或双链接的，可以是已排序的或未排序的，可以是循环的或非循环的。如果一个链表是 **单链接的**，则省略每个元素中的prev指针。如果链表是已排序的，则链表的线性顺序与链表元素中关键字的线性顺序一致；据此，最小的元素就是表头元素，而最大的元素则是表尾元素。如果链表是未排序的，则各元素可以以任何顺序出现。在 **循环链表**中，表头的prev指针指向表尾元素，而表尾元素的next指针则指向表头元素。我们可以将循环链表想象成一个各元素组成的圆环。
#### 链表的搜索
LIST-SEARCH(L, k)采用简单的线性搜索的方法，用于查找链表L中第一个关键字为k的元素，并返回指向该元素的指针。如果链表中没有关键字为k的对象，则该过程返回NIL。搜索一个有n个对象的链表，最坏情况下的运行时间为\\(\Theta(n)\\)。
#### 链表的插入
LIST-INSERT将x“连接入”到链表的前端，在一个含n个元素的链表上执行LIST-INSERT的运行时间是O(1)。
#### 链表的删除
过程LIST-DELETE将一个元素x从链表L中移除。该过程要求给定一个指向x的指针，然后通过修改一些指针，将x“删除出”该链表，运行时间为O(1)。如果要删除具有给定关键字值的元素，则必须先调用LIST-SEARCH找到该元素，最坏情况下运行时间为\\(\Theta(n)\\)。
#### 哨兵
> 链表中的哨兵虽然很少被提及，但是在LeetCode优秀的算法解法中常常出现。
实现上述操作过程时，往往要考虑表头表尾处的边界条件。

**哨兵（sentinel）**是一个哑对象，其作用是简化边界条件的处理。例如，假设在链表L中设置一个对象L.nil，该对象代表NIL，但也具有和其他对象相同的各个属性。对于链表代码中出现的每一处对NIL的引用，都代之以对哨兵L.nil的引用。这样的调整将一个常规的双向链表转变为一个 **有哨兵的双向循环链表**，哨兵L.nil位于表头和表尾之间。属性L.nil.next指向表头，L.nil.prev指向表尾。类似地，表尾的next属性和表头的prev属性同时指向L.nil。因为L.nil.next指向表头，我们就可以去掉属性L.head，并把对它的引用代替为对L.nil.next的引用。

哨兵基本不能降低数据结构相关操作的渐近时间界，但可以降低常数因子。然而，在另一些情况下，哨兵的使用使循环语句的代码更紧凑，从而降低了运行时间中\\(n\\)或\\(n^2\\)等项的系数。我们应当慎用哨兵。假如有许多个很短的链表，它们的哨兵所占用的额外的存储空间会造成严重的存储浪费。
