---
categories: Algo
tags: 数据结构 算法导论
# music-id: 20090402
---
## 基本数据结构
在本章中，我们要讨论如何通过使用指针的简单数据结构来表示动态集合。虽然运用指针可以构造多种复杂的数据结构，但这里只介绍几种基本的结构：栈、队列、链表和有根树。此外，我们还要介绍由数组构造对象和指针的方法。

### 栈和队列
**栈**中，被删除的是最近插入的元素，栈实现的是一种 **后进先出（LIFO）**策略。类似地，在队列中，被删去的总是在集合中存在的时间最长的那个元素：队列实现的是一种 **先进先出（FIFO）**策略。在计算机上实现栈和队列有几种有效的方式。
#### 栈
栈包含的操作有：PUSH、POP、STACK-EMPTY（判断栈是否为空）。
#### 队列
队列包含的操作有：ENQUEUE、DEQUEUE、QUEUE-EMPTY。
队列有队头和队尾，当有一个元素入队时，它被放在队尾位置，出队的元素则总是排在队头的那个。

### 链表
链表（Linked List），其中的各对象按线性顺序排列。数组的线性顺序是由数组下标决定的，然而与数组不同的是，链表的顺序是由各个对象里的指针决定的。链表为动态集合提供了一种简单而灵活的表示方法，并且能支持上节中列出的所有操作（但未必非常有效）。

链表可以有多种形式。它可以是单链接的或双链接的，可以是已排序的或未排序的，可以是循环的或非循环的。如果一个链表是 **单链接的**，则省略每个元素中的prev指针。如果链表是已排序的，则链表的线性顺序与链表元素中关键字的线性顺序一致；据此，最小的元素就是表头元素，而最大的元素则是表尾元素。如果链表是未排序的，则各元素可以以任何顺序出现。在 **循环链表**中，表头的prev指针指向表尾元素，而表尾元素的next指针则指向表头元素。我们可以将循环链表想象成一个各元素组成的圆环。
#### 链表的搜索
LIST-SEARCH(L, k)采用简单的线性搜索的方法，用于查找链表L中第一个关键字为k的元素，并返回指向该元素的指针。如果链表中没有关键字为k的对象，则该过程返回NIL。搜索一个有n个对象的链表，最坏情况下的运行时间为$\Theta(n)$。
#### 链表的插入
LIST-INSERT将x“连接入”到链表的前端，在一个含n个元素的链表上执行LIST-INSERT的运行时间是$O(1)$。
#### 链表的删除
过程LIST-DELETE将一个元素x从链表L中移除。该过程要求给定一个指向x的指针，然后通过修改一些指针，将x“删除出”该链表，运行时间为$O(1)$。如果要删除具有给定关键字值的元素，则必须先调用LIST-SEARCH找到该元素，最坏情况下运行时间为$\Theta(n)$。
#### 哨兵
> 链表中的哨兵虽然很少被提及，但是在LeetCode优秀的算法解法中常常出现。
实现上述操作过程时，往往要考虑表头表尾处的边界条件。

**哨兵（sentinel）**是一个哑对象，其作用是简化边界条件的处理。例如，假设在链表L中设置一个对象L.nil，该对象代表NIL，但也具有和其他对象相同的各个属性。对于链表代码中出现的每一处对NIL的引用，都代之以对哨兵L.nil的引用。这样的调整将一个常规的双向链表转变为一个 **有哨兵的双向循环链表**，哨兵L.nil位于表头和表尾之间。属性L.nil.next指向表头，L.nil.prev指向表尾。类似地，表尾的next属性和表头的prev属性同时指向L.nil。因为L.nil.next指向表头，我们就可以去掉属性L.head，并把对它的引用代替为对L.nil.next的引用。

哨兵基本不能降低数据结构相关操作的渐近时间界，但可以降低常数因子。然而，在另一些情况下，哨兵的使用使循环语句的代码更紧凑，从而降低了运行时间中$n$或$n^2$等项的系数。我们应当慎用哨兵。假如有许多个很短的链表，它们的哨兵所占用的额外的存储空间会造成严重的存储浪费。
### 指针和对象的实现
我所接触到的常用语言不存在 **同时不支持指针和对象数据类型**这种现象，在《算法导论》这本书中，考虑了该情况，对象用数组实现，而指针用数组下标实现。同时，该书还考虑了 **对象的分配与释放**，不愧是经典的算法教材。有兴趣的同学可以参阅该书P134-136。
### 有根树
链表的表示方法可以推广到任意同构的数据结构上。
#### 二叉树
链表中每一个元素有一个前驱，一个后继，还有一个元素值，所有元素都是同构的。
对于二叉树，每一个元素有一个父节点，一个左节点，一个右节点，所有元素也是同构的。
#### 分支无限制的有根树
树的孩子节点数无限制时，我们不知道预先分配多少个槽来存储孩子（指针），即使孩子数k限制在一个大的常数范围内，但若多数节点只有少量的孩子，则会浪费大量存储空间。

所幸的是，有一个巧妙的方法可以用来表示孩子数任意的树，该方法的优势在于，对任意n个节点的有根树，只需要$O(n)$的存储空间。这种**左孩子右兄弟表示法**为：
1. 每个节点都包含一个父节点指针p，且T.root指向树T的根节点；
2. x.left-child指向节点x最左边的孩子节点；
3. x.right-sibling指向x右侧相邻的兄弟节点。
4. 如果节点x没有孩子节点，x.left-child=NIL；如果节点x是其父节点的最右孩子，则x.right-sibling=NIL。

#### 树的其他表示方法
完全二叉树：堆（一个单数组+最末节点的下标表示）

还有很多其他的表示方法，哪种方法最优取决于具体应用。

## 散列表
待续...
## 二叉搜索树
待续...
## 红黑树
待续...
## 数据结构的扩张
待续...
